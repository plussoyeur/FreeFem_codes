/* Variables */
real [int,int] stats(lm.n,4);
real[int] xx(lm.n), yy(lm.n);
int size = 0; /* count */

NewMacro fitvortex(Tmesh,density,localmin,regions){
  /*===============================================================
    Loop over each basin of attraction
    ===============================================================*/
  for(int j = 0; j < localmin.n; j++){
    cout << "Nous sommes a l'iteration : " << j << " / " << localmin.n << endl;
  
    /* Trunc mesh -> reduce to one basin of attraction*/
    mesh Thj = trunc(Tmesh, floor(r)==localmin(j,1), label = -1); /* take the jth minimum*/

    /* Declare Pi sub-espace related to the truncated mesh*/
    fespace Vhj(Thj,P1);
    fespace Phj(Thj,P0);

    /* Restrict GPE solution to the truncated mesh*/
    Vhj rhoj = density;

    /* Compute useful parameters from truncated mesh*/
    int globalindmin = localmin(j,0); /*ind of min on the global mesh*/
    real xjG = Th(globalindmin).x; /* x coord for the min*/
    real yjG = Th(globalindmin).y; /* y coord for the min*/
    real rG = sqrt(xjG^2+yjG^2); /*dist from center of initial mesh*/

    /*===============================================================
       Restrict mesh by maximizing gradient
       ===============================================================*/

    
    varf vbord(u,v) = on(-1,u=rhoj); /* Define varf to extract values of uj on the border*/
    real[int] vb = vbord(0,Vhj,tgv=1); /* Stores these values in an array*/
    vb = vb ? vb : 10^8; /* If inside the truncated mesh : 0 -> 10‚Å∏*/
    int whereminborder = vb.imin; /* Find min on the border*/
    real xminborder = Thj(whereminborder).x; /* x coord of this min*/
    real yminborder = Thj(whereminborder).y; /* y coord of this min*/
    
    real radiusminborder = sqrt((xminborder-xjG)^2 + (yminborder-yjG)^2); /* Distance from the center of the mesh to the min on border*/
    mesh Thjj = trunc(Thj, (sqrt( (x-xjG)^2+(y-yjG)^2 ) < radiusminborder), label = -2 ); /* Trunc truncated mesh*/
  
    fespace Vhjj(Thjj,P1); /* Define P1 functional space on this new mesh*/
    fespace Phjj(Thjj,P0); /* Define P0 functional space on this new mesh*/

    Vhjj rhojj = rhoj; /* Restrict function on this new mesh*/

    /*===============================================================
      GAUSSIAN FIT : definition of functionnals and starting parameters
      ===============================================================*/
    // real[int] gauss(5), gaussinit(5); /*a,b,c,x0,y0*/
    // real[int] gausstilde(5);
    // real R = abs(rhojj[].max-rhojj[].min);
	
    // varf vbord2(uh,vh) = on(-2,uh=rhojj);
    // real[int] vb2 = vbord2(0,Vhjj,tgv=1);
    // vb2 = vb2 ? vb2 : 10^8;
    // cout << "Min border : " << vb2.min << endl;
    // real minborder = .6*vb2.min;
    // real val = sqrt(abs(log(minborder)));
    // cout << "Val : " << val << endl;
    
    // real[int,int] M(3,3);
    // M(0,0) = int1d(Thjj,levelset=rhojj-minborder)( (x-xjG)^4  );
    // M(0,1) = int1d(Thjj,levelset=rhojj-minborder)( 2*(x-xjG)^3*(y-yjG)  );
    // M(0,2) = int1d(Thjj,levelset=rhojj-minborder)( (x-xjG)^2*(y-yjG)^2  );
    // M(1,0) = int1d(Thjj,levelset=rhojj-minborder)( (x-xjG)^3*(y-yjG)  );
    // M(1,1) = int1d(Thjj,levelset=rhojj-minborder)( 2*(x-xjG)^2*(y-yjG)^2  );
    // M(1,2) = int1d(Thjj,levelset=rhojj-minborder)( (x-xjG)*(y-yjG)^3 );
    // M(2,0) = int1d(Thjj,levelset=rhojj-minborder)( (x-xjG)^2*(y-yjG)^2  );
    // M(2,1) = int1d(Thjj,levelset=rhojj-minborder)( 2*(y-yjG)^3*(x-xjG)  );
    // M(2,2) = int1d(Thjj,levelset=rhojj-minborder)( (y-yjG)^4  );
     
    // inv(M);

    // real[int] SM(3);
    // SM(0) = int1d(Thjj,levelset=rhojj-minborder)( (x-xjG)^2  )*val;
    // SM(1) = int1d(Thjj,levelset=rhojj-minborder)( (x-xjG)*(y-yjG)  )*val;
    // SM(2) = int1d(Thjj,levelset=rhojj-minborder)( (y-yjG)^2  )*val;

    // gaussinit(0:2) = M*SM;
    // gaussinit(3) = xjG;
    // gaussinit(4) = yjG;
    
    // gausstilde = gaussinit;
    // gauss = gaussinit;
    // cout << "Gauss param init : " << gauss << endl;

    
    // func ri2 = gauss[0]*(x-gauss[3])^2+2*gauss[1]*(x-gauss[3])*(y-gauss[4])+gauss[2]*(y-gauss[4])^2;
    // func fgauss = 1.-exp(-ri2^2);
    
    // func r2a = (x-gauss[3])^2;
    // func r2b = 2*(x-gauss[3])*(y-gauss[4]);
    // func r2c = (y-gauss[4])^2;
    // func r2x0 = -2*gauss[0]*(x-gauss[3])-gauss[1]*(y-gauss[4]);
    // func r2y0 = -2*gauss[2]*(y-gauss[4])-gauss[1]*(x-gauss[3]);
    
    // func fa = r2a*ri2*exp(-ri2^2);
    // func fb = r2b*ri2*exp(-ri2^2);
    // func fc = r2c*ri2*exp(-ri2^2);
    // func fx0 = r2x0*ri2*exp(-ri2^2);
    // func fy0 = r2y0*ri2*exp(-ri2^2);
   
    // /* Gaussian functionnal*/
    // func real Jgauss(real[int] & gausstilde){
    //   gauss = gausstilde;
    //   return int2d(Thjj)(0.5*abs(fgauss-rhojj)^2);
    // }

    // /* Gaussian functionnal derivative*/
    // func real[int] DJgauss(real [int] & gausstilde){
    //   gauss = gausstilde; 
    //   real[int] res(5);
    //   res[0] = int2d(Thjj)( 2*(fgauss-rhojj)*fa  );
    //   res[1] = int2d(Thjj)( 2*(fgauss-rhojj)*fb  );
    //   res[2] = int2d(Thjj)( 2*(fgauss-rhojj)*fc  );
    //   res[3] = int2d(Thjj)( 2*(fgauss-rhojj)*fx0  );
    //   res[4] = int2d(Thjj)( 2*(fgauss-rhojj)*fy0  );

    //   return res;
  
    // }

    macro f(r2) (1.-exp(r2))//
    macro f1(ff) log(1.-(ff)) // 
    macro df(r2,dr2) (dr2*-exp(r2))//

    real[int] alpha(5);
    

    
    func xx =alpha[0]-x;
    func yy =alpha[1]-y;
    func axx =  alpha[2]*xx*xx;
    func ayy =  alpha[3]*yy*yy;
    func axy =  alpha[4]*xx*yy;

    func r2 = axx+ayy+axy; 
    func d0r2 = (2*xx)*alpha[2]  + alpha[4]*yy;
    func d1r2 = (2*yy)*alpha[3]  + alpha[4]*xx; 
    func d2r2 = xx*xx ; 
    func d3r2 = yy*yy ; 
    func d4r2 = xx*yy ; 


    func phialpha   = f(r2);

    func d0phialpha = df(r2,d0r2);
    func d1phialpha = df(r2,d1r2);
    func d2phialpha = df(r2,d2r2);
    func d3phialpha = df(r2,d3r2);
    func d4phialpha = df(r2,d4r2);

    real aa = int1d(Thjj)(1.); 
    real uu = int1d(Thjj)(rhojj);
    real ux = uu/aa; 
    real um =ux/2;
    real l0 = int1d(Thjj,levelset=rhojj-um)(1.);
    real x0 = int1d(Thjj,levelset=rhojj-um)(x)/l0;
    real y0 = int1d(Thjj,levelset=rhojj-um)(y)/l0;
    alpha[0]=xjG;
    alpha[1]=yjG;
    alpha[2]=1;
    alpha[3]=1;
    alpha[4]=0;
	
    real r20 = int1d(Thjj,levelset=rhojj-um)(xx*xx+yy*yy)/l0;

    // um  sim (alpha[0]*f(r20*alpha[3])

    real s0 =  f1(um/ux)/r20 ;
    cout << " s0 = " <<  s0 << " " << r20  <<" "<< endl; 
    alpha[2]=s0;
    alpha[3]=s0;

    Vhjj phi, phi0 = phialpha;
    cout << "alpha = " <<  alpha << endl; 
    //if(displayplot>1) plot(rhojj,phi0, wait=1);
 
    //plot(phi0, wait=1);

    real[int]  data0 = alpha;

    func real J(real[int] & dat){
      alpha=dat; 
      return int2d(Thjj)(square(rhojj-phialpha)) ;
    }
    real[int] dataJ(alpha.n);
    func real[int]  dJ(real[int] & dat){
	
      alpha=dat;
      dataJ=0; 
      dataJ[0]=int2d(Thjj)(-2*(rhojj-phialpha)*d0phialpha) ;
      dataJ[1]=int2d(Thjj)(-2*(rhojj-phialpha)*d1phialpha) ;
      dataJ[2]=int2d(Thjj)(-2*(rhojj-phialpha)*d2phialpha) ;
      dataJ[3]=int2d(Thjj)(-2*(rhojj-phialpha)*d3phialpha) ;
      dataJ[4]=int2d(Thjj)(-2*(rhojj-phialpha)*d4phialpha) ;

      return dataJ; 
    }
      
    /*===============================================================
       Fit using Ipopt
       ===============================================================*/
    cout << "********************************" << endl;
    cout << "Start Ipopt" << endl;
    cout << "********************************" << endl;
    cout << endl;
    cout << endl;

    if(displayplot > 5){
      /* Where is the vortex on the global mesh*/
      Phj wherej = 1;
      Ph where = wherej;
      string  titlewhere = "Vortex " + j;
      plot(where,fill=1,wait=1,cmm=titlewhere);
      /* Initial guess and solution of GPE */
      plot(Thj, wait=1, cmm= "Frist truncated mesh");
      plot(Thjj, wait = 1, cmm = "New truncated mesh"); /* Plot new mesh*/
      plot(rhojj, wait=1, cmm = "Solution of the GPE on the truncated mesh"); /*Plot the restricted solution on the truncated mesh*/
      /* Norm*/
      real normbeforeipopt = sqrt(int2d(Thjj)( (rhojj-phi0)^2 ));
      cout << "Norm 2 before ipopt : " << normbeforeipopt << endl;
      string titleinit = "Initial guess for the Gaussian fit. Norm =  " + normbeforeipopt; 
      plot(phi0,rhojj,wait=1,cmm=titleinit);
    }



    
    /* Ipopt;*/
    bool vr;
    real[int] fitdata=data0;
    
    vr = IPOPT(J,dJ,fitdata);
    cout << "Ipopt convergence : " << vr << endl;     
    cout << endl;
    cout << "****************************" << endl;
    cout << "Init gauss parameters : " << data0 << endl;
    cout << "Gauss parameters after IPOPT : " << fitdata << endl;

    /* If user wants plots to be displayed*/
    if(displayplot > 5){
      /* Result of the fitting*/
      alpha = fitdata;
      phi = phialpha;
      plot(phi, wait=1, cmm="Final fit");
      /* Norm*/
      real normafteripopt = sqrt(int2d(Thjj)( (rhojj-phi)^2 ));
      cout << "Norm 2 after ipopt : " << normafteripopt << endl;
      string titleafter =  "Display of rhoj and its fit. Norm =  " + normafteripopt;
      plot(phi,rhojj,wait=1,cmm = titleafter);
      Vhjj diff = abs( (phi-rhojj) / rhojj);
      plot(diff,wait=1,cmm = "Difference");

    }      

    cout << endl;
    cout << endl;
    cout << "********************************" << endl;
    cout << "End IPOPT" << endl;
    cout << "********************************" << endl;

    /*===============================================================
       Stats
       ===============================================================*/
    /*xx[size] = xjG;
    yy[size] = yjG;

    real eigval1 = .5*(ionut[0]+ionut[2]+sqrt( (ionut[0]-ionut[2])^2 + 4*ionut[1]^2   )   );
    real eigval2 = .5*(ionut[0]+ionut[2]-sqrt( (ionut[0]-ionut[2])^2 + 4*ionut[1]^2   )   );

    real eccentricity = sqrt(1 - min(eigval1,eigval2)^2/max(eigval1,eigval2)^2 );
    real sharpness = sqrt(pi*eigval1*eigval2);

    stats(size,0) = rG;
    stats(size,1) = R;
    stats(size,2) = eccentricity;
    stats(size,3) = sharpness;

    size++;   */   

  }

  /*xx.resize(size);
  yy.resize(size);

  stats.resize(size,4);

  mesh Thv = triangulate(xx,yy);
  if(displayplot > 5) plot(Thv, wait=1);
  if(displayplot > 5) plot(Thv, rho, wait=1);
  cout << "Number of vertex : " << Thv.nv << endl;


  {
    ofstream datastats("stats.dat");
    datastats << stats << endl;
    }*/

}
EndMacro

fitvortex(Th,rho,lmtrue,r)