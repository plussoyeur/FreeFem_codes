/* Variables */
real [int,int] stats(lm.n,4);
real[int] xx(lm.n), yy(lm.n);
int size = 0; /* count */

NewMacro fitvortex(Tmesh,density,localmin,regions){
  /*===============================================================
    Loop over each basin of attraction
    ===============================================================*/
  for(int j = 0; j < localmin.n; j++){
    cout << "Nous sommes a l'iteration : " << j << " / " << localmin.n << endl;
  
    /* Trunc mesh -> reduce to one basin of attraction*/
    mesh Thj = trunc(Tmesh, floor(r)==localmin(j,1), label = -1); /* take the jth minimum*/

    /* Declare Pi sub-espace related to the truncated mesh*/
    fespace Vhj(Thj,P1);
    fespace Phj(Thj,P0);

    /* Restrict GPE solution to the truncated mesh*/
    Vhj rhoj = density;

    /* Compute useful parameters from truncated mesh*/
    int globalindmin = localmin(j,0); /*ind of min on the global mesh*/
    real xjG = Th(globalindmin).x; /* x coord for the min*/
    real yjG = Th(globalindmin).y; /* y coord for the min*/
    real rG = sqrt(xjG^2+yjG^2); /*dist from center of initial mesh*/

    /*===============================================================
       Restrict mesh by taking the lowest isovalue on the border
       ===============================================================*/

    
    varf vbord(u,v) = on(-1,u=rhoj); /* Define varf to extract values of uj on the border*/
    real[int] vb = vbord(0,Vhj,tgv=1); /* Stores these values in an array*/
    vb = vb ? vb : 10^8; /* If inside the truncated mesh : 0 -> 10‚Å∏*/
    int whereminborder = vb.imin; /* Find min on the border*/
    real xminborder = Thj(whereminborder).x; /* x coord of this min*/
    real yminborder = Thj(whereminborder).y; /* y coord of this min*/
    
    real radiusminborder = sqrt((xminborder-xjG)^2 + (yminborder-yjG)^2); /* Distance from the center of the mesh to the min on border*/
    mesh Thjj = trunc(Thj, (sqrt( (x-xjG)^2+(y-yjG)^2 ) < radiusminborder), label = -2 ); /* Trunc truncated mesh*/
  
    fespace Vhjj(Thjj,P1); /* Define P1 functional space on this new mesh*/
    fespace Phjj(Thjj,P0); /* Define P0 functional space on this new mesh*/

    Vhjj rhojj = rhoj; /* Restrict function on this new mesh*/

    /*===============================================================
      Starting parameters : solving a linear system to fit an ellipse
      ===============================================================*/
    real[int] alpha(5), alphainit(5); /*x0,y0,a,b,c*/
    real[int] alphatilde(5);
    real R = abs(rhojj[].max-rhojj[].min);
	
    varf vbord2(uh,vh) = on(-2,uh=rhojj);
    real[int] vb2 = vbord2(0,Vhjj,tgv=1);
    vb2 = vb2 ? vb2 : 10^8;
    cout << "Min border : " << vb2.min << endl;
    real minborder = .6*vb2.min;
    real val = sqrt(abs(log(minborder)));
    cout << "Val : " << val << endl;
    
    real[int,int] M(3,3);
    M(0,0) = int1d(Thjj,levelset=rhojj-minborder)( (x-xjG)^4  );
    M(0,1) = int1d(Thjj,levelset=rhojj-minborder)( (x-xjG)^3*(y-yjG)  );
    M(0,2) = int1d(Thjj,levelset=rhojj-minborder)( (x-xjG)^2*(y-yjG)^2  );
    M(1,0) = int1d(Thjj,levelset=rhojj-minborder)( (x-xjG)^3*(y-yjG)  );
    M(1,1) = int1d(Thjj,levelset=rhojj-minborder)( (x-xjG)^2*(y-yjG)^2  );
    M(1,2) = int1d(Thjj,levelset=rhojj-minborder)( (x-xjG)*(y-yjG)^3 );
    M(2,0) = int1d(Thjj,levelset=rhojj-minborder)( (x-xjG)^2*(y-yjG)^2  );
    M(2,1) = int1d(Thjj,levelset=rhojj-minborder)( (y-yjG)^3*(x-xjG)  );
    M(2,2) = int1d(Thjj,levelset=rhojj-minborder)( (y-yjG)^4  );
     
    inv(M);

    real[int] SM(3);
    SM(0) = int1d(Thjj,levelset=rhojj-minborder)( (x-xjG)^2  )*val;
    SM(1) = int1d(Thjj,levelset=rhojj-minborder)( (x-xjG)*(y-yjG)  )*val;
    SM(2) = int1d(Thjj,levelset=rhojj-minborder)( (y-yjG)^2  )*val;

    alphainit(2:4) = M*SM;
    alphainit(0) = xjG;
    alphainit(1) = yjG;
    
    alphatilde = alphainit;
    alpha = alphainit;
    cout << "Gauss param init : " << alpha << endl;

    /*===============================================================
      GAUSSIAN functionals and functionnal derivative : definition
      ===============================================================*/
    
    macro f(r2) (1.-exp(-r2))//
    macro df(r2,dr2) (dr2*exp(-r2))//
    
    func xx = x-alpha[0];
    func yy = y-alpha[1];
    
    func r2 = alpha[2]*xx*xx + alpha[3]*xx*yy + alpha[4]*yy*yy;

    func d0r2 = -2*alpha[2]*xx - alpha[3]*yy;
    func d1r2 = -2*alpha[4]*yy - alpha[3]*xx;
    func d2r2 = xx*xx;
    func d3r2 = xx*yy;
    func d4r2 = yy*yy; 
       
    func fgauss = f(r2);
    
    func dfx0 = df(r2,d0r2);
    func dfy0 = df(r2,d1r2);
    func dfa = df(r2,d2r2);
    func dfb = df(r2,d3r2);
    func dfc = df(r2,d4r2);

   
    /* Gaussian functionnal*/
    func real Jgauss(real[int] & alphatilde){
      alpha = alphatilde;
      return int2d(Thjj)(0.5*abs(fgauss-rhojj)^2);
    }

    /* Gaussian functionnal derivative*/
    func real[int] DJgauss(real [int] & alphatilde){
      alpha = alphatilde; 
      real[int] res(5);
      res[0] = int2d(Thjj)( (fgauss-rhojj)*dfx0  );
      res[1] = int2d(Thjj)( (fgauss-rhojj)*dfy0  );
      res[2] = int2d(Thjj)( (fgauss-rhojj)*dfa  );
      res[3] = int2d(Thjj)( (fgauss-rhojj)*dfb  );
      res[4] = int2d(Thjj)( (fgauss-rhojj)*dfc  );

      return res;
  
    }
      
    /*===============================================================
       Fit using Ipopt
       ===============================================================*/
    cout << "********************************" << endl;
    cout << "Start Ipopt" << endl;
    cout << "********************************" << endl;
    cout << endl;
    cout << endl;

    if(displayplot > 3 && wwait == 1){
      /* Where is the vortex on the global mesh*/
      Phj wherej = 1;
      Ph where = wherej;
      string  titlewhere = "Vortex " + j;
      plot(where,fill=1,wait=1,cmm=titlewhere);
      /* Initial guess and solution of GPE */
      plot(Thj, wait=1, cmm= "Frist truncated mesh");
      plot(Thjj, wait = 1, cmm = "New truncated mesh"); /* Plot new mesh*/
      plot(rhojj, wait=1, cmm = "Solution of the GPE on the truncated mesh"); /*Plot the restricted solution on the truncated mesh*/
      /* Norm*/
      Vhjj fgaussinit = fgauss;
      real normbeforeipopt = sqrt(int2d(Thjj)( (rhojj-fgaussinit)^2 ));
      cout << "Norm 2 before ipopt : " << normbeforeipopt << endl;

      string titleinit = "Initial guess for the Gaussian fit. Norm2 = " + normbeforeipopt; 
      plot(fgaussinit,rhojj,dim=3,wait=wwait,cmm=titleinit);
    }
    
    /* Ipopt;*/
    bool vr;
    vr = IPOPT(Jgauss,DJgauss,alphatilde,printlevel = 0);

    
    cout << "Ipopt convergence : " << vr << endl;     
    cout << endl;
    cout << "****************************" << endl;
    cout << "Init gauss parameters : " << alphainit << endl;
    cout << "Gauss parameters after IPOPT : " << alphatilde << endl;

    /* If user wants plots to be displayed*/
    if(displayplot > 3){
      /* Result of the fitting*/
      alpha = alphatilde;
      Vhjj fgaussfinal = fgauss;
      /* Norm*/
      real normafteripopt = sqrt(int2d(Thjj)( (rhojj-fgaussfinal)^2 ));
      cout << "Norm 2 after ipopt : " << normafteripopt << endl;

      string titleafter = "Display of rhoj and its fit. Norm2 = " + normafteripopt;
      //plot(fgaussfinal, wait=1, cmm="Final fit");
      plot(fgaussfinal,rhojj,dim=3,wait=wwait,cmm = titleafter);

      if(wwait == 1){ 
	Vhjj diff = abs( (fgaussfinal-rhojj) / rhojj);
	plot(diff,wait=1,cmm = "Difference");
      }
    }      

    cout << endl;
    cout << endl;
    cout << "********************************" << endl;
    cout << "End IPOPT" << endl;
    cout << "********************************" << endl;

    /*===============================================================
       Stats
       ===============================================================*/
    /*xx[size] = xjG;
    yy[size] = yjG;

    real eigval1 = .5*(ionut[0]+ionut[2]+sqrt( (ionut[0]-ionut[2])^2 + 4*ionut[1]^2   )   );
    real eigval2 = .5*(ionut[0]+ionut[2]-sqrt( (ionut[0]-ionut[2])^2 + 4*ionut[1]^2   )   );

    real eccentricity = sqrt(1 - min(eigval1,eigval2)^2/max(eigval1,eigval2)^2 );
    real sharpness = sqrt(pi*eigval1*eigval2);

    stats(size,0) = rG;
    stats(size,1) = R;
    stats(size,2) = eccentricity;
    stats(size,3) = sharpness;

    size++;   */   

  }

  /*xx.resize(size);
  yy.resize(size);

  stats.resize(size,4);

  mesh Thv = triangulate(xx,yy);
  if(displayplot > 5) plot(Thv, wait=1);
  if(displayplot > 5) plot(Thv, rho, wait=1);
  cout << "Number of vertex : " << Thv.nv << endl;


  {
    ofstream datastats("stats.dat");
    datastats << stats << endl;
    }*/

}
EndMacro

fitvortex(Th,rho,lmtrue,r)