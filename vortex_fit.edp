// Program to fit vortex from a pre-computed simulation
load "Element_P4";
load "iovtk";
load "ff-Ipopt";
load "gsl";
load "pipe";
load "isoline";
load "BEC";

ofstream fout("output.echo",append);

//===============================================================
// load functions and mesh
//===============================================================

include "BEC_2D_Macros.idp";
real ITER0=0.;

mesh Th = readmesh("BEC_2D-Classical-N-140000-Omega-1000_iter_00301.msh");


plot(Th, wait=1);

fespace Vh (Th,P1);
fespace Vh4(Th,P4);
fespace Vh2(Th,[P1,P1]);
fespace Ph (Th,P0);

Vh<complex> u, uconj;
Vh          ur, ui, umod, argu,u0; // real, imag parts and mod of the solution
real        Normu; // norm of the solution \int(u^2)

restartloadint(u,"/home/plussoyeur/Documents/Stage_FreeFem/Freefem_github/BEC_2D-Classical-N-140000-Omega-1000_iter_00301","/home/plussoyeur/Documents/Stage_FreeFem/Freefem_github/BEC_2D-Classical-N-140000-Omega-1000_iter_00301",ITER0);

BECnormalize(Th,u,Normu,ur,ui,umod,"Initial cond : ",fout);

plot(umod,wait=1);

Ph dist = sqrt(x^2+y^2);
cout << "Distance max = " << dist[].max << endl;


//===============================================================
// Fit
//===============================================================
Ph r;

//int[int] lm=findalllocalmin(Th,umod[],r[],convex=0,eps=0);
int[int] lm=findalllocalmin(Th,umod[],r[]);
plot(r, u, fill=1, wait=1);

cout << "lm : "<< lm << endl;
// Loop over each minimum
for(int j = 0; j < lm.n; j++){
  cout << "Iter : " << j << "sur " << lm.n << endl;
  
  int val = lm(j); // jth value in tab lm
  mesh Thj = trunc(Th, floor(r)==val); // trunc mesh by taking the triangles where r matched the desired value
  plot(Thj);
  fespace Vhj(Thj,P1); //P1 espace for this sub-mesh
  fespace Phj(Thj,P0); //P0 espace for this sub-mesh
  Vhj uj = umod; // Restrict solution of GPE to this sub-mesh
  string title = "current value : " + j;
  plot(uj, wait = 1, cmm=title);
  
  // Useful starting parameters
  int mini = uj[].imin;
  real xjG = Thj(mini).x;
  real yjG = Thj(mini).y;
  real ampl = uj[].min - uj[].max;
  real H = uj[].max;

  Phj r2 = sqrt((x-xjG)^2+(y-yjG)^2);
  real sig = r2[].max;


  
  //********************************************************************************
  // GAUSSIAN FIT
  
  // Parameters
  real[int] a(6);
  real[int] alpha(6);

  alpha[0] = ampl;
  alpha[1] = xjG;
  alpha[2] = sig;
  alpha[3] = yjG;
  alpha[4] = sig;
  alpha[5] = H;

  // Construct gaussian functionnal
  func real Jgauss(real[int] & alpha){
    for(int i = 0; i < alpha.n; i++) a[i] = alpha[i];
    func gaf = a[5] + a[0]*exp(-(x-a[1])^2/(2*a[2]^2))*exp(-(y-a[3])^2/(2*a[4]^2));
    Vhj ga = gaf;
    real s = int2d(Thj)(.5*abs(ga-uj)^2);
    return s;
  }

  // Construct gaussian functionnal derivative
  func real[int] DJgauss(real[int] & alpha){
    for(int i = 0; i < alpha.n; i++) a[i] = alpha[i];
    func gaf = a[5] + a[0]*exp(-(x-a[1])^2/(2*a[2]^2))*exp(-(y-a[3])^2/(2*a[4]^2));
    Vhj ga = gaf;
    func dgaf0 = exp(-(x-a[1])^2/(2*a[2]^2))*exp(-(y-a[3])^2/(2*a[4]^2));
    Vhj dga0 = dgaf0;
    func dgaf1 = a[0]*(x-a[1])/a[2]^2*exp(-(x-a[1])^2/(2*a[2]^2))*exp(-(y-a[3])^2/(2*a[4]^2));
    Vhj  dga1 = dgaf1;
    func dgaf2 = a[0]*(x-a[1])^2/a[2]^3*exp(-(x-a[1])^2/(2*a[2]^2))*exp(-(y-a[3])^2/(2*a[4]^2));
    Vhj dga2 = dgaf2;
    func dgaf3 = a[0]*(y-a[3])/a[4]^2*exp(-(x-a[1])^2/(2*a[2]^2))*exp(-(y-a[3])^2/(2*a[4]^2));
    Vhj  dga3 = dgaf3;
    func dgaf4 = a[0]*(y-a[3])^2/a[4]^3*exp(-(x-a[1])^2/(2*a[2]^2))*exp(-(y-a[3])^2/(2*a[4]^2));
    Vhj dga4 = dgaf2;
    func dgaf5 = 1;
    Vhj dga5 = dgaf5;

    real[int] res(6);
    res(0) = int2d(Thj)( (ga-uj)*dga0 );
    res(1) = int2d(Thj)( (ga-uj)*dga1 );
    res(2) = int2d(Thj)( (ga-uj)*dga2 );
    res(3) = int2d(Thj)( (ga-uj)*dga3 );
    res(4) = int2d(Thj)( (ga-uj)*dga4 );
    res(5) = int2d(Thj)( (ga-uj)*dga5 );

    return res;
  }
  //********************************************************************************


  
  //********************************************************************************
  // LORENTZIAN FIT
  real[int] beta(5);
  real[int] b(5);
  beta[0] = -ampl;
  beta[1] = sig/5;
  beta[2] = xjG;
  beta[3] = yjG;
  beta[4] = H;

  // Lorentzian functionnal
  func real Jlorent(real[int] & beta){
    for(int i = 0; i < beta.n; i++) b[i] = beta[i];
    func gaf = b(4) - b[0]*b[1]^2/( b[1]^2+ (x-b[2])^2 + (y-b[3])^2  );
    Vhj ga = gaf;
    real s = int2d(Thj)( .5*abs(ga-uj)^2 );
    return s;
  }

  // Lorentzian functionnal derivative
  func real[int] DJlorent(real[int] & beta){
    for(int i = 0; i < beta.n; i++) b[i] = beta[i];
    func gaf = b[4] - b[0]*b[1]^2/( b[1]^2+ (x-b[2])^2 + (y-b[3])^2  );
    Vhj ga = gaf;
    func dgaf0 = -b[1]^2/( b[1]^2+ (x-b[2])^2 + (y-b[3])^2  ); ;
    Vhj dga0 = dgaf0;
    func dgaf1 = -2*b[0]*b[1]*( (x-b[2])^2 + (y-b[3])^2 )/( (b[1]^2+ (x-b[2])^2 + (y-b[3])^2)^2  );;
    Vhj dga1 = dgaf1;
    func dgaf2 = -2*b[0]*b[1]^2*(x-b[2])/( (b[1]^2+ (x-b[2])^2 + (y-b[3])^2)^2  ) ;
    Vhj dga2 = dgaf2;
    func dgaf3 = -2*b[0]*b[1]^2*(y-b[3])/( (b[1]^2+ (x-b[2])^2 + (y-b[3])^2)^2  ) ;
    Vhj dga3 = dgaf3;
    func dgaf4 = 1;
    Vhj dga4 = dgaf4;

    real[int] res(5);
    res(0) = int2d(Thj)( (ga-uj)*dga0 );
    res(1) = int2d(Thj)( (ga-uj)*dga1 );
    res(2) = int2d(Thj)( (ga-uj)*dga2 );
    res(3) = int2d(Thj)( (ga-uj)*dga3 );
    res(4) = int2d(Thj)( (ga-uj)*dga4 );

    return res;
  }



  //********************************************************************************
  
  

  
  // Fit using BFGS
  cout << "********************************" << endl;
  cout << "Start BFGS" << endl;
  cout << "********************************" << endl;
  cout << endl;
  cout << endl;
  cout << alpha << endl;
  cout << "Hauteur : " << ampl << endl;
  real rG = sqrt(xjG^2+yjG^2);
  cout << "Iter : " << j << "   centre   " << rG << endl;
  //cout << "Alpha init : " << alpha << endl;
  cout << "Beta init : " << beta << endl;
  cout << endl;
  cout << endl;
  // If not close to the border
  if(rG < 12){
    if(abs(ampl) > 0.001){

      //func gaf0 = alpha[5] + alpha[0]*exp(-(x-alpha[1])^2/(2*alpha[2]^2))*exp(-(y-alpha[3])^2/(2*alpha[4]^2));
      //Vhj ga0 = gaf0;
      func gaf0 = beta[4] - beta[0]*beta[1]^2/( beta[1]^2+ (x-beta[2])^2 + (y-beta[3])^2  );;
      Vhj ga0 = gaf0;
      
      plot(ga0,wait=1,cmm = "Init !!!");
      //BFGS(Jgauss,DJgauss,alpha,eps=1.e-6,nbiter=15,nbiterline=20); // Gaussian
      BFGS(Jlorent,DJlorent,beta,eps=1.e-10,nbiter=15,nbiterline=20); // Lorentzian
      //func gaf = alpha[5] + alpha[0]*exp(-(x-alpha[1])^2/(2*alpha[2]^2))*exp(-(y-alpha[3])^2/(2*alpha[4]^2));
      //Vhj ga = gaf;
      func gaf = beta[4] - beta[0]*beta[1]^2/( beta[1]^2+ (x-beta[2])^2 + (y-beta[3])^2  );;
      Vhj ga = gaf;
      string title2 = "Iter : " + j + "   uj and ga ";
      plot(uj,wait=1, cmm = "uj");
      plot(ga,wait=1, cmm = "ga");
      plot(uj,ga,wait=1,cmm=title2);

      cout << endl;
      cout << "******************" << endl;
      cout << "Beta after BFGS : " << beta << endl;
    }
  }
  cout << endl;
  cout << endl;
  cout << "********************************" << endl;
  cout << "End BFGS" << endl;
  cout << "********************************" << endl;
  

 }