// Program to fit vortex from a pre-computed simulation
load "iovtk";
load "ff-Ipopt";
load "gsl";
load "pipe";
load "isoline";
load "BEC";
load "fflapack"

ofstream fout("output.echo",append);

//===============================================================
// load functions and mesh
//===============================================================

include "BEC_2D_Macros.idp";
real ITER0=0.;

mesh Th = readmesh("BEC_2D-Classical-N-140000-Omega-1000_iter_00301.msh");


plot(Th, wait=1, cmm="Initial mesh");

fespace Vh (Th,P1);
fespace Ph (Th,P0);

Vh<complex> u, uconj;
Vh          ur, ui, umod, argu,u0; // real, imag parts and mod of the solution
real        Normu; // norm of the solution \int(u^2)

// Load solution
restartloadint(u,"/home/plussoyeur/Documents/Stage_FreeFem/Freefem_github/BEC_2D-Classical-N-140000-Omega-1000_iter_00301","/home/plussoyeur/Documents/Stage_FreeFem/Freefem_github/BEC_2D-Classical-N-140000-Omega-1000_iter_00301",ITER0);

// Normalize solution (should already be ok)
BECnormalize(Th,u,Normu,ur,ui,umod,"Initial cond : ",fout);

// Compute distance from center
Ph dist = sqrt(x^2+y^2);
real distmax = dist[].max;
cout << "BEC radius : " << distmax << endl;

//===============================================================
// Find minima
//===============================================================
Ph r;

//**************************************************
// Call findalllocalmin in isoline.cpp to find basins of attraction
//**************************************************
// lm stores vertex ind where min is reached;
// r attributes vertex to its jth minimum
int[int] lm=findalllocalmin(Th,umod[],r[]);
real[int] xx(lm.n), yy(lm.n);

// Plot region matching basins of attraction
plot(r, fill=1, wait=1,  cmm="Basins of attraction");

int size = 0;
//**************************************************
// Loop over each basin of attraction
//**************************************************
for(int j = 0; j < lm.n; j++){
  //cout << "Nous sommes a l'iteration : " << j << " / " << lm.n << endl;
  
  // Trunc mesh -> reduce to one basin of attraction
  mesh Thj = trunc(Th, floor(r)==j, label = -1); // take the jth minimum

  if(Thj.nt > 20){
    // Declare Pi sub-espace related to the truncated mesh
    fespace Vhj(Thj,P1);
    fespace Phj(Thj,P0);

    // Restrict GPE solution to the truncated mesh
    Vhj uj = umod;

    int globalindmin = lm[j];
    real xjG = Th(globalindmin).x; // x coord for the min
    real yjG = Th(globalindmin).y; // y coord for the min
    real rG = sqrt(xjG^2+yjG^2); //dist from center of initial mesh
    real ampl = uj[].max - uj[].min;            

    if(rG < distmax*.75){ //if not to close from border
      
      // varf vbord(u,v) = on(-1,u=uj); // Define varf to extract values of uj on the border
      // real[int] vb = vbord(0,Vhj,tgv=1); // Stores these values in an array
      // vb = vb ? vb : 10^8; // If inside the truncated mesh : 0 -> 10‚Å∏
      // int whereminborder = vb.imin; // Find min on the border
      // real xminborder = Thj(whereminborder).x; // x coord of this min
      // real yminborder = Thj(whereminborder).y; // y coord of this min
      // real radiusminborder = sqrt((xminborder-xjG)^2 + (yminborder-yjG)^2); // Distance from the center of the mesh to the min on border

      // mesh Thjj = trunc(Thj, (sqrt( (x-xjG)^2+(y-yjG)^2 ) < .8*radiusminborder), label = -2 ); // Trunc truncated mesh
      // fespace Vhjj(Thjj,P1); // Define P1 functional space on this new mesh
      // fespace Phjj(Thjj,P0); // Define P0 functional space on this new mesh

      // cout << Thjj.nt << endl;
      
      // //plot(Thj, wait=1, cmm="Thj");
      // //plot(Thjj, wait=1, cmm="Thjj");
      
      // Vhjj ujj = uj; // Restrict function on this new mesh

      // varf vbord2(u,v) = on(-2,u=ujj);
      // real[int] vbb = vbord2(0,Vhjj,tgv=1);

      // real maxborder = vbb.max;
      // real minvortex = ujj[].min;

      // real depthrate = abs(minvortex/maxborder);

      // cout << "Min : " << minvortex << "    Max border : " << maxborder << endl;


      xx[size] = xjG;
      yy[size] = yjG;
      size++;
	
      }
  }
 }

xx.resize(size);
yy.resize(size);

mesh Thv = triangulate(xx,yy);
plot(Thv, wait=1);
plot(Thv, umod, wait=1);
cout << "Number of vertex : " << Thv.nv << endl;